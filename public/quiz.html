<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>AI Revision Quiz</title>

  <!-- jsPDF for PDF export -->
  <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; background:#0b1220; color:#fff; margin:0; padding:20px; }
    .box { max-width: 1100px; margin:auto; background:#111a2e; padding:20px; border-radius:12px; }
    h1 { margin:0 0 6px; }
    .meta { opacity:.85; margin-bottom:10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    button { padding:10px 14px; border-radius:10px; border:0; cursor:pointer; font-weight:600; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input[type="file"], input[type="number"], select { padding:8px; border-radius:10px; border:0; }
    input[type="number"] { width: 90px; }

    .status { margin-top:12px; padding:10px; border-radius:10px; background:rgba(255,255,255,.08); }
    .status.ok { background:rgba(56,211,159,.15); }
    .status.bad { background:rgba(255,107,107,.15); }

    .card { margin-top:14px; padding:14px; border-radius:12px; background:rgba(255,255,255,.06); }
    .grid { display:grid; grid-template-columns:1fr 300px; gap:14px; }
    @media (max-width:900px){ .grid{grid-template-columns:1fr;} }

    .options label {
      display:block; padding:10px; border-radius:10px;
      background:rgba(255,255,255,.06); margin:10px 0; cursor:pointer;
      border: 2px solid transparent;
    }

    .feedback { margin-top:10px; font-weight:700; }
    .feedback.ok{color:#38d39f} .feedback.bad{color:#ff6b6b}

    .pill { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.1); display:inline-flex; gap:8px; align-items:center; }
    .tiny { font-size: .92rem; opacity:.85; }

    .list { border-radius:10px; overflow:hidden; }
    .list button{
      width:100%; background:rgba(255,255,255,.06); border:0; padding:10px;
      text-align:left; color:#fff;
    }
    .list button.active{background:rgba(56,211,159,.25)}

    /* Highlight states after Check */
    .opt-correct { border-color: rgba(56,211,159,.9); background: rgba(56,211,159,.18) !important; }
    .opt-wrong   { border-color: rgba(255,107,107,.9); background: rgba(255,107,107,.15) !important; }
    .opt-dim { opacity: .8; }
  </style>
</head>

<body>
<div class="box">
  <h1>AI Revision Quiz</h1>
  <div class="meta">
    Get Questions = start (or change page range). Continue = generate Next 20 from the same pages.
  </div>

  <div class="card">
    <div class="row">
      <input type="file" id="pdfFile" accept="application/pdf">

      <span class="pill">Start
        <input type="number" id="startPage" min="1" placeholder="e.g. 1">
      </span>

      <span class="pill">End
        <input type="number" id="endPage" min="1" placeholder="e.g. 5">
      </span>

      <button id="getBtn">Get Questions</button>
      <button id="continueBtn" disabled>Continue (Next 20)</button>
      <button id="resetBtn">Reset</button>
      <button id="exportPdfBtn" disabled>Export PDF</button>

      <select id="mode">
        <option value="all">All</option>
        <option value="incorrect">Incorrect</option>
      </select>
    </div>

    <div id="status" class="status">Upload a PDF, set page range, then click Get Questions.</div>
    <div class="tiny">Shortcuts: 1–4 pick A–D, Enter = Check/Next.</div>
  </div>

  <div class="grid" id="quizGrid" style="display:none">
    <div class="card">
      <div id="progress"></div>
      <h3 id="prompt"></h3>
      <div class="options" id="options"></div>

      <div class="row">
        <button id="checkBtn">Check</button>
        <button id="nextBtn" disabled>Next</button>
      </div>

      <div id="feedback" class="feedback"></div>
    </div>

    <div class="card">
      <h3>Jump to</h3>
      <div class="list" id="jumpList"></div>
    </div>
  </div>
</div>

<script>
/* =======================
   Storage + Server Session
   ======================= */
const SESSION = "quiz_generate_continue_v1";
const LS_BANK = SESSION + "_bank";
const LS_STATE = SESSION + "_state";
const LS_SERVER_SID = SESSION + "_server_session_id";
const LS_ACTIVE_RANGE = SESSION + "_active_range";

let BANK = JSON.parse(localStorage.getItem(LS_BANK) || "[]");
let state = JSON.parse(localStorage.getItem(LS_STATE) || '{"pos":0,"answers":{},"mode":"all"}');
let activeRange = JSON.parse(localStorage.getItem(LS_ACTIVE_RANGE) || "null"); // {start,end} or null

const $ = (id) => document.getElementById(id);

function saveBrowserState(){
  localStorage.setItem(LS_BANK, JSON.stringify(BANK));
  localStorage.setItem(LS_STATE, JSON.stringify(state));
  localStorage.setItem(LS_ACTIVE_RANGE, JSON.stringify(activeRange));
}
function clearBrowserState(){
  localStorage.removeItem(LS_BANK);
  localStorage.removeItem(LS_STATE);
  localStorage.removeItem(LS_ACTIVE_RANGE);
  BANK = [];
  state = { pos: 0, answers: {}, mode: "all" };
  activeRange = null;
}

function newSessionId(){
  return "sid_" + Math.random().toString(16).slice(2) + "_" + Date.now();
}
function getServerSessionId(){
  let sid = localStorage.getItem(LS_SERVER_SID);
  if(!sid){
    sid = newSessionId();
    localStorage.setItem(LS_SERVER_SID, sid);
  }
  return sid;
}
function rotateServerSessionId(){
  localStorage.removeItem(LS_SERVER_SID);
  localStorage.setItem(LS_SERVER_SID, newSessionId());
}

/* =======================
   Helpers
   ======================= */
function setStatus(msg, type=""){
  $("status").textContent = msg;
  $("status").className = "status " + type;
}

function queue(){
  return BANK.map((_, i) => i).filter(i => {
    if(state.mode === "incorrect") return state.answers[i]?.correct === false;
    return true;
  });
}

function clearHighlights(){
  document.querySelectorAll("#options label").forEach(lab => {
    lab.classList.remove("opt-correct", "opt-wrong", "opt-dim");
  });
}

function applyHighlights(idxInBank){
  const correct = BANK[idxInBank].answer;
  const selected = state.answers[idxInBank]?.selected;

  document.querySelectorAll("#options label").forEach(lab => {
    const inp = lab.querySelector("input");
    if(!inp) return;

    const val = inp.value;
    lab.classList.add("opt-dim");

    if(val === correct){
      lab.classList.remove("opt-dim");
      lab.classList.add("opt-correct");
    }
    if(selected && selected !== correct && val === selected){
      lab.classList.remove("opt-dim");
      lab.classList.add("opt-wrong");
    }
  });
}

/* Deduplicate questions to reduce repeats (client-side safety net) */
function questionKey(q){
  const opts = q.options || {};
  return [
    (q.prompt || "").trim(),
    (opts.A || "").trim(),
    (opts.B || "").trim(),
    (opts.C || "").trim(),
    (opts.D || "").trim(),
    (q.answer || "").trim()
  ].join("||");
}

function appendDedup(existing, incoming){
  const seen = new Set(existing.map(questionKey));
  const out = [...existing];
  let added = 0;

  for(const q of incoming){
    const k = questionKey(q);
    if(!seen.has(k)){
      seen.add(k);
      out.push(q);
      added++;
    }
  }
  return { out, added };
}

/* =======================
   UI Render
   ======================= */
function renderJump(){
  const q = queue();
  const list = $("jumpList");
  list.innerHTML = "";
  if(!q.length) return;

  const WINDOW = 5;
  const start = Math.max(0, state.pos - WINDOW);
  const end = Math.min(q.length - 1, state.pos + WINDOW);

  if(start > 0){
    const more = document.createElement("div");
    more.className = "tiny";
    more.style.padding = "8px 10px";
    more.textContent = `… ${start} earlier`;
    list.appendChild(more);
  }

  for(let p = start; p <= end; p++){
    const bi = q[p];
    const b = document.createElement("button");

    const mark = state.answers[bi]
      ? (state.answers[bi].correct ? "✅ " : "❌ ")
      : "⬜ ";

    b.textContent = `${mark}Q${bi + 1}`;
    if(p === state.pos) b.classList.add("active");

    b.onclick = () => {
      state.pos = p;
      saveBrowserState();
      renderQuestion();
    };

    list.appendChild(b);
  }

  if(end < q.length - 1){
    const more = document.createElement("div");
    more.className = "tiny";
    more.style.padding = "8px 10px";
    more.textContent = `… ${q.length - end - 1} more`;
    list.appendChild(more);
  }
}

function renderQuestion(){
  const q = queue();
  if(!q.length){
    $("quizGrid").style.display = "none";
    return;
  }
  $("quizGrid").style.display = "grid";

  if(state.pos < 0) state.pos = 0;
  if(state.pos >= q.length) state.pos = q.length - 1;

  const idx = q[state.pos];
  const item = BANK[idx];

  const rangeText = activeRange ? `Pages ${activeRange.start}–${activeRange.end}` : "No active page range";
  $("progress").textContent = `${rangeText} • Mode: ${state.mode.toUpperCase()} • Q${idx + 1} / ${BANK.length}`;
  $("prompt").textContent = item.prompt;

  $("options").innerHTML = "";
  const saved = state.answers[idx]?.selected;

  ["A","B","C","D"].forEach(l => {
    const lab = document.createElement("label");
    const opt = item.options?.[l] || "";
    lab.innerHTML =
      `<input type="radio" name="ans" value="${l}" ${saved === l ? "checked" : ""}>
       <b>${l})</b> ${opt}`;
    $("options").appendChild(lab);
  });

  $("feedback").textContent = "";
  $("feedback").className = "feedback";
  $("nextBtn").disabled = true;
  clearHighlights();

  if(state.answers[idx]){
    const ok = state.answers[idx].correct;
    const correct = BANK[idx].answer;
    $("feedback").textContent = ok ? `Correct! (Answer: ${correct})` : `Wrong. Correct answer: ${correct}`;
    $("feedback").className = "feedback " + (ok ? "ok" : "bad");
    $("nextBtn").disabled = false;
    applyHighlights(idx);
  }

  renderJump();
  saveBrowserState();
}

function ensurePdfSelected(){
  const f = $("pdfFile").files[0];
  if(!f){
    setStatus("Please select the PDF file again (browser requires this for generating).", "bad");
    alert("Please select the PDF file again.");
    return null;
  }
  return f;
}

function readRangeFromInputs(){
  const start = $("startPage").value;
  const end = $("endPage").value;
  if(!start || !end){
    setStatus("Please enter BOTH start and end page numbers.", "bad");
    alert("Please enter BOTH start and end page numbers.");
    return null;
  }
  return { start: String(start), end: String(end) };
}

/* =======================
   Generation (core)
   ======================= */
let isGenerating = false;

async function generateNextBatch({ freshStart }) {
  if (isGenerating) return;
  const pdf = ensurePdfSelected();
  if (!pdf) return;

  const range = freshStart ? readRangeFromInputs() : activeRange;
  if (!range){
    setStatus("No active page range. Use Get Questions first.", "bad");
    return;
  }

  // If freshStart, we overwrite activeRange and start a new server session
  if (freshStart) {
    activeRange = { start: range.start, end: range.end };
    saveBrowserState();
  }

  isGenerating = true;
  $("getBtn").disabled = true;
  $("continueBtn").disabled = true;

  const actionText = freshStart ? "Generating first batch…" : "Generating next 20…";
  setStatus(actionText + " please wait.", "");

  const fd = new FormData();
  fd.append("session_id", getServerSessionId());
  fd.append("pdf", pdf);
  fd.append("start_page", activeRange.start);
  fd.append("end_page", activeRange.end);

  try{
    const r = await fetch("/api/next-20", { method:"POST", body: fd });
    const d = await r.json().catch(() => ({}));

    if(!r.ok){
      setStatus(d.error || `Server error ${r.status}`, "bad");
      console.error(d);
      return;
    }

    // Expect server returns new questions in d.mcq (or full list). We'll handle both safely.
    const incoming = Array.isArray(d.mcq) ? d.mcq :
                     Array.isArray(d.questions) ? d.questions :
                     Array.isArray(d.items) ? d.items : [];

    if (!incoming.length){
      setStatus("Server returned no questions. Try a smaller page range or click again.", "bad");
      console.error("No questions in response:", d);
      return;
    }

    // If freshStart, clear bank/progress first (start truly fresh)
    if (freshStart) {
      BANK = [];
      state = { pos: 0, answers: {}, mode: "all" };
      $("mode").value = "all";
    }

    // Append + dedupe
    const beforeLen = BANK.length;
    const { out, added } = appendDedup(BANK, incoming);
    BANK = out;

    // Keep user on the same question if they were already mid-quiz
    // For freshStart, state.pos stays 0.
    if (!freshStart) {
      // do nothing: keep state.pos as-is
    }

    saveBrowserState();

    $("exportPdfBtn").disabled = (BANK.length === 0);
    $("continueBtn").disabled = (BANK.length === 0);

    const shownAdded = (typeof d.added === "number") ? d.added : added;
    const dedupNote = (added !== incoming.length) ? ` (dedup kept ${added}/${incoming.length})` : "";
    const modeNote = `Pages ${activeRange.start}–${activeRange.end}`;

    setStatus(`${modeNote}: added ${shownAdded}. Total questions: ${BANK.length}${dedupNote}`, "ok");

    renderQuestion();
    $("quizGrid").scrollIntoView({ behavior:"smooth", block:"start" });

  } catch(err){
    console.error(err);
    setStatus("Network error. Please refresh and try again.", "bad");
  } finally {
    isGenerating = false;
    $("getBtn").disabled = false;
    $("continueBtn").disabled = (BANK.length === 0);
  }
}

/* =======================
   Buttons behaviour you want
   ======================= */

/* Get Questions:
   - used at START
   - used when changing page range later
   - starts FRESH (clears bank) + new server session id
*/
$("getBtn").onclick = async () => {
  const pdf = ensurePdfSelected();
  if (!pdf) return;

  const range = readRangeFromInputs();
  if (!range) return;

  // Start new session for new range so server won't complain about mixing PDFs/pages
  rotateServerSessionId();

  // Generate first batch fresh
  await generateNextBatch({ freshStart: true });
};

/* Continue:
   - generates Next 20 for the SAME range
   - appends to existing bank
*/
$("continueBtn").onclick = async () => {
  if (BANK.length === 0 || !activeRange) {
    setStatus("No active session yet. Upload PDF + range and click Get Questions first.", "bad");
    return;
  }

  // If user is in incorrect mode but queue is empty, switch to all so UI shows
  if (queue().length === 0) {
    state.mode = "all";
    $("mode").value = "all";
    state.pos = 0;
    saveBrowserState();
  }

  await generateNextBatch({ freshStart: false });
};

/* Reset */
$("resetBtn").onclick = async () => {
  $("getBtn").disabled = true;
  $("continueBtn").disabled = true;
  $("exportPdfBtn").disabled = true;
  setStatus("Resetting…", "");

  // best-effort server reset
  try{
    const sid = getServerSessionId();
    const fd = new FormData();
    fd.append("session_id", sid);
    await fetch("/api/reset", { method:"POST", body: fd });
  } catch(e){
    console.warn("Server /api/reset not available or failed (ok):", e);
  }

  clearBrowserState();
  rotateServerSessionId();

  $("pdfFile").value = "";
  $("startPage").value = "";
  $("endPage").value = "";
  $("mode").value = "all";

  $("quizGrid").style.display = "none";
  $("feedback").textContent = "";
  $("feedback").className = "feedback";

  $("getBtn").disabled = false;
  setStatus("Reset complete. Upload a PDF, set pages, then click Get Questions.", "ok");
};

/* Mode change */
$("mode").onchange = (e) => {
  state.mode = e.target.value;
  state.pos = 0;
  saveBrowserState();
  renderQuestion();
};

/* Check / Next */
$("checkBtn").onclick = () => {
  const sel = document.querySelector("input[name=ans]:checked");
  if(!sel) return alert("Select an option first.");

  const q = queue();
  const idx = q[state.pos];

  const correct = BANK[idx].answer;
  const ok = sel.value === correct;

  state.answers[idx] = { selected: sel.value, correct: ok };

  $("feedback").textContent = ok ? `Correct! (Answer: ${correct})` : `Wrong. Correct answer: ${correct}`;
  $("feedback").className = "feedback " + (ok ? "ok" : "bad");
  $("nextBtn").disabled = false;

  clearHighlights();
  applyHighlights(idx);

  saveBrowserState();
  renderJump();
};

$("nextBtn").onclick = () => {
  const q = queue();
  if(!q.length) return;

  if(state.pos < q.length - 1){
    state.pos++;
    saveBrowserState();
    renderQuestion();
  } else {
    alert("End of this review mode. You can Continue to generate more, or change pages and Get Questions again.");
  }
};

/* Keyboard shortcuts */
window.addEventListener("keydown", (e) => {
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
  if(tag === "input" || tag === "select" || tag === "textarea") return;

  const map = { "1":"A", "2":"B", "3":"C", "4":"D" };
  if(map[e.key]){
    const el = document.querySelector(`input[name="ans"][value="${map[e.key]}"]`);
    if(el) el.checked = true;
  }

  if(e.key === "Enter"){
    if($("nextBtn").disabled) $("checkBtn").click();
    else $("nextBtn").click();
  }
});

/* Export PDF */
$("exportPdfBtn").onclick = () => {
  const JsPDF = window.jspdf?.jsPDF;
  if(!JsPDF){
    alert("PDF export library did not load. Please refresh and try again.");
    return;
  }
  if(!BANK.length){
    alert("No questions to export yet.");
    return;
  }

  const doc = new JsPDF({ unit: "mm", format: "a4" });
  const pageH = doc.internal.pageSize.getHeight();
  const pageW = doc.internal.pageSize.getWidth();

  const left = 12;
  const right = 12;
  const maxW = pageW - left - right;

  let y = 14;

  doc.setFont("helvetica", "bold");
  doc.setFontSize(14);
  doc.text("AI Revision Quiz", left, y);
  y += 8;

  doc.setFont("helvetica", "normal");
  doc.setFontSize(10);
  const rangeText = activeRange ? `Pages ${activeRange.start}–${activeRange.end}` : "Pages: -";
  doc.text(`Exported: ${new Date().toLocaleString()} • ${rangeText}`, left, y);
  y += 8;

  doc.setFontSize(11);

  function addWrapped(text, indent=0){
    const lines = doc.splitTextToSize(String(text || ""), maxW - indent);
    for(const line of lines){
      if(y > pageH - 14){
        doc.addPage();
        y = 14;
      }
      doc.text(line, left + indent, y);
      y += 5;
    }
  }

  BANK.forEach((q, i) => {
    doc.setFont("helvetica", "bold");
    addWrapped(`Q${i+1}`, 0);
    doc.setFont("helvetica", "normal");
    addWrapped(q.prompt, 0);

    addWrapped(`A) ${q.options?.A || ""}`, 2);
    addWrapped(`B) ${q.options?.B || ""}`, 2);
    addWrapped(`C) ${q.options?.C || ""}`, 2);
    addWrapped(`D) ${q.options?.D || ""}`, 2);

    const your = state.answers[i]?.selected || "-";
    const status = state.answers[i] ? (state.answers[i].correct ? "Correct" : "Wrong") : "Unanswered";
    addWrapped(`Correct: ${q.answer}  |  Your answer: ${your} (${status})`, 0);

    y += 4;
  });

  doc.save("ai-revision-quiz.pdf");
};

/* Restore on load */
$("mode").value = state.mode || "all";
getServerSessionId();

if(BANK.length){
  $("continueBtn").disabled = false;
  $("exportPdfBtn").disabled = false;
  const rangeText = activeRange ? `Pages ${activeRange.start}–${activeRange.end}` : "No active pages";
  setStatus(`Restored saved session. ${rangeText}. Total questions: ${BANK.length}`, "ok");
  renderQuestion();
} else {
  setStatus("Upload a PDF, set page range, then click Get Questions.", "");
}
</script>
</body>
</html>
